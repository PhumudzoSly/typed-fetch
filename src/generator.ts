import { dirname } from "path";
import { loadConfig } from "./core/config";
import { clearRegistry, loadRegistry } from "./core/registry";
import { shapeToTypeScript } from "./core/shape";
import type { Registry, ShapeNode, TypedFetchConfig } from "./core/types";

function stableSortedEntries<T>(record: Record<string, T>): Array<[string, T]> {
  return Object.entries(record).sort((a, b) => a[0].localeCompare(b[0]));
}

function ensureDir(path: string): void {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const fs = require("fs") as typeof import("fs");
  if (!fs.existsSync(path)) {
    fs.mkdirSync(path, { recursive: true });
  }
}

function writeFile(path: string, content: string): void {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const fs = require("fs") as typeof import("fs");
  ensureDir(dirname(path));
  fs.writeFileSync(path, content, "utf8");
}

function readFile(path: string): string | null {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const fs = require("fs") as typeof import("fs");
  if (!fs.existsSync(path)) {
    return null;
  }
  return fs.readFileSync(path, "utf8");
}

function getShapeOrUnknown(shape: ShapeNode | undefined): ShapeNode {
  return shape ?? { kind: "unknown" };
}

function renderEndpointResponses(registry: Registry): string {
  const endpointLines: string[] = [];

  for (const [endpointKey, endpoint] of stableSortedEntries(
    registry.endpoints,
  )) {
    const statusLines: string[] = [];
    for (const [status, shape] of stableSortedEntries(endpoint.responses)) {
      statusLines.push(
        `      ${status}: ${shapeToTypeScript(getShapeOrUnknown(shape))};`,
      );
    }
    endpointLines.push(
      `    ${JSON.stringify(endpointKey)}: {\n${statusLines.join("\n")}\n    };`,
    );
  }

  return endpointLines.join("\n");
}

export function generateTypes(
  configOverrides: Partial<TypedFetchConfig> = {},
  options: { configPath?: string } = {}
): {
  outputPath: string;
  content: string;
  warnings: string[];
} {
  const config = loadConfig(configOverrides, options);
  const registry = loadRegistry(config.registryPath);

  const endpoints = renderEndpointResponses(registry);
  const content = `/* eslint-disable */
/* This file is auto-generated by @phumudzo/typed-fetch. Do not edit manually. */

declare module "@phumudzo/typed-fetch" {
  interface TypedFetchGeneratedResponses {
${endpoints}
  }
}

export {};
`;

  writeFile(config.generatedPath, content);
  const warnings: string[] = [];
  for (const [endpointKey, endpoint] of stableSortedEntries(registry.endpoints)) {
    const observedPaths = endpoint.meta.observedPaths ?? [];
    if (observedPaths.length > 1) {
      warnings.push(
        `Potential endpoint-key collision for "${endpointKey}": ${observedPaths.join(", ")}`,
      );
    }
  }

  return { outputPath: config.generatedPath, content, warnings };
}

export function checkTypes(
  configOverrides: Partial<TypedFetchConfig> = {},
  options: { configPath?: string } = {}
): {
  ok: boolean;
  outputPath: string;
} {
  const config = loadConfig(configOverrides, options);
  const registry = loadRegistry(config.registryPath);
  const endpoints = renderEndpointResponses(registry);
  const expected = `/* eslint-disable */
/* This file is auto-generated by @phumudzo/typed-fetch. Do not edit manually. */

declare module "@phumudzo/typed-fetch" {
  interface TypedFetchGeneratedResponses {
${endpoints}
  }
}

export {};
`;
  const actual = readFile(config.generatedPath);
  return {
    ok: actual === expected,
    outputPath: config.generatedPath,
  };
}

export function cleanArtifacts(
  configOverrides: Partial<TypedFetchConfig> = {},
  options: { configPath?: string } = {},
  args: { generated?: boolean; registry?: boolean } = {},
): void {
  const config = loadConfig(configOverrides, options);
  const removeGenerated = args.generated || (!args.generated && !args.registry);
  const removeRegistry = args.registry || (!args.generated && !args.registry);

  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const fs = require("fs") as typeof import("fs");

  if (removeGenerated && fs.existsSync(config.generatedPath)) {
    fs.rmSync(config.generatedPath, { force: true });
  }
  if (removeRegistry) {
    clearRegistry(config.registryPath);
  }
}
